---
title: Linux内核模块无法卸载分析与修复(1)
date: 2022-04-20 23:56:33
tags:
- gcc
- kernel
categories: Kernel
---
近期遇到一个服务器上我们的内核模块无法卸载的问题。`rmmod`返回错误信息:
```plain
Device or resource busy
```

Google上搜索一下，其他人也遇到过类似的问题，原因基本指向是编译内核模块的`gcc`版本和编译内核的`gcc`版本不一致。

* https://goodcommand.readthedocs.io/zh_CN/latest/bs/rmmod_device_or_resource_busy.html
* https://stackoverflow.com/questions/17251822/not-able-to-remove-a-loadable-kernel-module

<!--more-->

于是开始检查我们的环境。我们的服务器系统是`CentOS 7.8 ARM`:
```bash
[root@localhost ~]# cat /etc/redhat-release
CentOS Linux release 7.8.2003 (AltArch)
[root@localhost ~]# uname -a
Linux localhost.localdomain 4.18.0-147.8.1.el7.aarch64 #1 SMP Wed Apr 15 18:13:44 UTC 2020 aarch64 aarch64 aarch64 GNU/Linux
```

查看编译内核的`gcc`版本，使用的是`gcc 8.3.1`:
```bash
[root@localhost ~]# cat /proc/version
Linux version 4.18.0-147.8.1.el7.aarch64 (mockbuild@aarch64-02.bsys.centos.org) (gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC)) #1 SMP Wed Apr 15 18:13:44 UTC 2020
```

查看业务模块的`gcc`版本, 使用的是`gcc 4.8.5`, 确实不一致:
```bash
[root@localhost ~]# readelf -p .comment xxx.ko

String dump of section '.comment':
  [     1]  GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-39)
  [    2f]  GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-39)
```

查看一下编译机器的`gcc`版本，确实是`gcc 4.8.5`, `yum`安装和镜像中默认自带的`gcc`都是这个版本。
```bash
[root@localhost ~]# rpm -qa |grep gcc
gcc-4.8.5-39.el7.aarch64
libgcc-4.8.5-39.el7.aarch64
gcc-gfortran-4.8.5-39.el7.aarch64
gcc-c++-4.8.5-39.el7.aarch64
```

现在看大概率是`gcc`版本的问题，但是具体原因需要继续定位。为了进一步缩小排查范围，写了一个简单的没有业务逻辑的内核模块来复现问题。

`kdemo.c`代码如下:
```c
#define pr_fmt(fmt) "[%s]: " fmt, KBUILD_MODNAME

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>

static int __init kdemo_init(void)
{
    pr_info("loaded\n");
    return 0;
}

static void __exit kdemo_exit(void)
{
    pr_info("unloaded\n");
}

module_init(kdemo_init);
module_exit(kdemo_exit);

MODULE_LICENSE("GPL");
```

`Makefile`内容:
```makefile
KBUILD_CFLAGS += -O0

obj-m += kdemo.o

all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

我们安装和内核编译使用的`gcc`一致的版本:
```bash
yum install -y devtoolset-8-gcc devtoolset-8-gcc-c++
source /opt/rh/devtoolset-8/enable
```
此时`gcc`版本为:
```bash
[root@localhost kdemo2]# gcc --version
gcc (GCC) 8.3.1 20190311 (Red Hat 8.3.1-3)
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

`gcc 8.3.1`编译的`kdemo.ko`可以正常卸载，而`gcc 4.8.5`编译的`kdemo.ko`无法卸载。

`rmmod`命令会调用`delete_module`系统调用，那就从`delete_module`源码分析。`Device or resource busy`错误消息来源于错误码`EBUSY`, 而`delete_module`中返回`EBUSY`的位置只有如下两处:
```c
        /* Doing init or already dying? */
        if (mod->state != MODULE_STATE_LIVE) {
                /* FIXME: if (force), slam module count damn the torpedoes */
                pr_debug("%s already dying\n", mod->name);
                ret = -EBUSY;
                goto out;
        }

        /* If it has an init func, it must have an exit func to unload */
        if (mod->init && !mod->exit) {
                forced = try_force_unload(flags);
                if (!forced) {
                        /* This module can't be removed */
                        ret = -EBUSY;
                        goto out;
                }
        }
```

我们可以通过开发额外的内核模块来调用`find_module`找到无法卸载的模块来查看具体结构内容。模块代码如下:
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>

static int __init ms_init(void)
{
    struct module *mod;

    printk(KERN_INFO "[moduleshow] loaded\n");

    mod = find_module("kdemo");
    if (mod == NULL) {
        printk(KERN_INFO "kdemo not found\n");
        return -1;
    }

    printk(KERN_INFO "MOD: 0x%lx\n", (unsigned long)mod);
    printk(KERN_INFO "STATE: %d\n", mod->state);
    printk(KERN_INFO "INIT: 0x%lx\n", (unsigned long)mod->init);
    printk(KERN_INFO "EXIT: 0x%lx\n", (unsigned long)mod->exit);
    printk(KERN_INFO "REFCOUNT: %u\n", atomic_read(&mod->refcnt));

    return -1;
}

module_init(ms_init);

MODULE_LICENSE("GPL");
```

加载使用`gcc 8.3.1`后的`ms.ko`模块, 可以从`dmesg`或者`/var/log/messages`中看到模块输出:
```plain
[39379.108779] [moduleshow] loaded
[39379.109010] MOD: 0xffff00000a3a0000
[39379.109227] STATE: 0
[39379.109364] INIT: 0xffff0000089f0000
[39379.109585] EXIT: 0x0
[39379.109728] REFCOUNT: 1
```

可以确认用`gcc 4.8.5`编译的内核模块无法卸载的原因是由于`mod`的`exit`函数指针为空。

接下来需要分析`exit`为空的原因。后文继续。

参考:

* https://blog.csdn.net/gatieme/article/details/75108154
* https://www.cnblogs.com/arnoldlu/p/9752061.html
* https://programmer.group/modle_init-and-modle_exit-principles-of-kernel-modules.html
* https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/06/02/linux-loadable-module
* https://kernelgo.org/kprobe.html
* https://blog.packagecloud.io/how-to-extract-and-disassmble-a-linux-kernel-image-vmlinuz/
* http://chuquan.me/2018/05/21/elf-introduce/
* https://linux.die.net/man/2/init_module
* https://www.researchgate.net/publication/261599172_Robust_Linux_memory_acquisition_with_minimal_target_impact/fulltext/53d20bd40cf228d363e8fe21/Robust-Linux-memory-acquisition-with-minimal-target-impact.pdf
